const cp = require("child_process");
// command line syntax : node -e 'require("./app.js").problem1()'

const problems = {
  // cmd: node -e 'console.log(require("./app.js").factors(600851475143))'
  factors: function (n) {
    // Collect factors as discovered
    let returnObject = {
      factors: [1, n],
      primeFactors: [],
    };
    // Example: 28
    // 28 / [1] = [28] --> [1,28] (given)
    // 28 / [2] = [14] --> [1,28,2,14]
    // 14 / [2] =  [7] --> [1,28,2,14,2,7]
    //  7 / [1] =  [7] --> [1,28,2,14,2,7,1,7]
    //  7 is prime, no more values
    // De-duped -> [1,28,2,14,7]
    // Although this method performs fast because it iteratively halves the
    // numerator, it misses values, in this case 4. But the missing value can
    // be detected by investigating the factors for repeated numnbers.
    // 1 repeats 1 + 1 = 2 ->> 2 is already there
    // 2 repeats 2 + 2 = 4 ->> 4 is missing need to add it
    // 7 repeeats 7 + 7 = 14 ->> 14 is already there

    // Find numbers, starting at two, that divide the input number
    // with 0 remainder
    for (let test = 2; test < n; test++) {
      if (n % test == 0) {
        let result = n / test;
        // "test" is a factor of n so add it to the collection
        returnObject.factors.push(test);
        // the result of the factor test is also a factor of n, add it.
        returnObject.factors.push(result);

        // Determine what are the factores of our new factors,
        // these will aslo be factors of n
        // But to avoid endless loop do not retest input n
        if (n != test) {
          let testResults = problems.factors(test);
          // Merge the data into the return object
          returnObject.factors = returnObject.factors.concat(
            testResults.factors
          );
          returnObject.primeFactors = returnObject.primeFactors.concat(
            testResults.primeFactors
          );
        }
        if (n != result) {
          let resultResults = problems.factors(result);
          // Merge the data into the return object
          returnObject.factors = returnObject.factors.concat(
            resultResults.factors
          );
          returnObject.primeFactors = returnObject.primeFactors.concat(
            resultResults.primeFactors
          );
        }

        // No need to continue the loop, other factors will be discovered
        // by the nested "factors" calls
        break;
      }
    }

    // Is n prime?
    // Need 2 true conditions
    if (
      returnObject.factors.length == 2 &&
      returnObject.factors.includes(n) &&
      returnObject.factors.includes(1)
    ) {
      returnObject.primeFactors.push(n);
    }
    // Test for hidden factors
    returnObject.factors.forEach((f) => {
      if (n % f == 0 && !returnObject.factors.includes(n / f)) {
        returnObject.factors.push(n / f);
      }
    });
    // De-duplicate
    let ddFactors = [];
    returnObject.factors.forEach((f) => {
      if (!ddFactors.includes(f)) ddFactors.push(f);
    });
    returnObject.factors = ddFactors;
    // De-duplicate
    let ddPrimeFactors = [];
    returnObject.primeFactors.forEach((f) => {
      if (!ddPrimeFactors.includes(f)) ddPrimeFactors.push(f);
    });
    returnObject.primeFactors = ddPrimeFactors;
    // Send the Object back
    // console.log(JSON.stringify(returnObject));
    return returnObject;
  },

  isPrime: function (n) {
    let factors = [];
    // even numbers are never primes except 2 && 1 is not prime
    if (n == 2 || (n % 2 != 0 && n > 1)) {
      for (let test = 1; test <= n; test++) {
        if (n % test == 0) {
          factors.push(test);
          if (test != n && test != 1) {
            // we already know that n cannot be prime, no need to keep looking
            break;
          }
        }
      }
    }
    return JSON.stringify(factors) == JSON.stringify([1, n]);
  },

  problem1: function () {
    // If we list all the natural numbers below 10 that are multiples of 3 or 5,
    // we get 3, 5, 6, and 9. The sum of these multiples is 23.
    //
    // Find the sum of all the multiples of 3 or 5 below 1000.
    let answer = 0;
    for (let naturalNumber = 1; naturalNumber < 1000; naturalNumber++) {
      if (naturalNumber % 3 == 0 || naturalNumber % 5 == 0) {
        answer += naturalNumber;
      }
    }
    console.log("Problem 1: " + answer);
  },

  problem2: function () {
    // Each new term in the Fibonacci sequence is generated by adding the previous two terms.
    // By starting with 1 and 2 , the first 10 terms will be:
    //        1, 2, 3, 4, 5, 8, 13, 21, 34, 55, 89,...
    //
    // By considering the terms in the Fibonacci sequence whose values do not exceed
    // four million, find the sum of the even-valued terms.
    let answer = 2;
    let fibonacciTerms = [1, 2];
    let newTerm = fibonacciTerms.slice(-1)[0] + fibonacciTerms.slice(-2)[0];
    while (newTerm <= 4000000) {
      fibonacciTerms.push(newTerm);
      if (newTerm % 2 == 0) {
        answer += newTerm;
      }

      newTerm = fibonacciTerms.slice(-1)[0] + fibonacciTerms.slice(-2)[0];
    }
    console.log("Problem 2: " + answer);
  },

  //cmd: node -e 'require("./app.js").problem3(600851475143)'
  problem3: function (n) {
    // The prime factors of 13195 are 5, 7, 13, and 29.
    //
    // What is the largest prime factor of the number 600851475143?
    let answer = 0;
    let objFactors = problems.factors(n);
    objFactors.primeFactors.forEach((pf) => {
      if (pf > answer) answer = pf;
    });

    console.log("Problem 3: " + answer);
  },

  problem4: function () {
    //A palindromic number reads the same both ways. The largest palindrome
    // made from the product of two -digit numbers is 9009 = 91 x 99.
    //
    // Find the largest palindrome made from the product of two 3-digit numbers.
    let answer = 0;
    // decending index loop
    for (let factor1 = 999; factor1 > 99; factor1--) {
      for (let factor2 = 999; factor2 > 99; factor2--) {
        let result = factor1 * factor2;

        if (
          result.toString() == result.toString().split("").reverse().join("")
        ) {
          if (result > answer) {
            answer = result;
          }
        }
      }
    }
    console.log("Problem 4: " + answer);
  },

  problem5: function () {
    // 2520 is the smallest number that can be divided by each of the numbers from
    // 1 to 10 without any remainder.
    //
    //What is the smallest positive number that is evenly divisible by all of the
    // numbers from 1 to 20?
    let answer = 0;
    let multiples = [];
    let test = 1;
    while (answer == 0) {
      let sumRemainders = 0;
      for (let n = 1; n <= 20; n++) {
        sumRemainders += test % n; // = 0 id n is a factor of test
      }
      if (sumRemainders == 0) {
        answer = test;
      }
      test++;
    }
    console.log("Problem 5: " + answer);
  },

  problem6: function () {
    // The sum of the squares of the first ten natural numbers is,
    // 1^2 + 2^2 + ... + 10^2 = 385.
    // The square of the sum of the first ten natural numbers is,
    // ( 1 + 2 + ... + 10 )^2 = 55^2 = 3025.
    //
    // Hence the difference between the sum of the squares of the first ten natural numbers
    // and the square of the sum is 3025 − 385 = 2640.
    // Find the difference between the sum of the squares of the first one hundred natural numbers
    // and the square of the sum.

    let answer = 0;
    let sumOfSquares = 0;
    let sumOfNaturalNumbers = 0;
    for (let nn = 1; nn <= 100; nn++) {
      sumOfNaturalNumbers += nn;
      sumOfSquares += Math.pow(nn, 2);
    }
    answer = Math.pow(sumOfNaturalNumbers, 2) - sumOfSquares;

    console.log("Problem 6: " + answer);
  },

  problem7: function () {
    // By listing the first six prime numbers: 2,3,5,7,11, and 13,
    // we can see that the 6th prime is 13.
    //
    // What is the 10001st prime number?
    let answer = 0;
    let primes = [];
    let test = 2; // We now 0 and 1 are not prime numbers.
    // 10001st item in primes is index 10000
    while (!primes[10000]) {
      if (this.isPrime(test)) primes.push(test);
      test++;
    }
    console.log("Problem 7: " + primes[10000]);
  },

  problem8: function () {
    // The four adjacent digits in the 1000-digit number that have the greatest product are
    // 9 x 9 x 8 x 9 = 5832.
    //
    // Find the thirteen adjacent digits in the
    // 1000-digit number that have the greatest product. What is the value of this product?
    let answer = 0;
    let digitsString =
      "73167176531330624919225119674426574742355349194934" +
      "96983520312774506326239578318016984801869478851843" +
      "85861560789112949495459501737958331952853208805511" +
      "12540698747158523863050715693290963295227443043557" +
      "66896648950445244523161731856403098711121722383113" +
      "62229893423380308135336276614282806444486645238749" +
      "30358907296290491560440772390713810515859307960866" +
      "70172427121883998797908792274921901699720888093776" +
      "65727333001053367881220235421809751254540594752243" +
      "52584907711670556013604839586446706324415722155397" +
      "53697817977846174064955149290862569321978468622482" +
      "83972241375657056057490261407972968652414535100474" +
      "82166370484403199890008895243450658541227588666881" +
      "16427171479924442928230863465674813919123162824586" +
      "17866458359124566529476545682848912883142607690042" +
      "24219022671055626321111109370544217506941658960408" +
      "07198403850962455444362981230987879927244284909188" +
      "84580156166097919133875499200524063689912560717606" +
      "05886116467109405077541002256983155200055935729725" +
      "71636269561882670428252483600823257530420752963450";

    let digitArray = digitsString.split("");

    for (let i = 0; i < digitArray.length - 13; i++) {
      let test =
        digitArray[i] *
        digitArray[i + 1] *
        digitArray[i + 2] *
        digitArray[i + 3] *
        digitArray[i + 4] *
        digitArray[i + 5] *
        digitArray[i + 6] *
        digitArray[i + 7] *
        digitArray[i + 8] *
        digitArray[i + 9] *
        digitArray[i + 10] *
        digitArray[i + 11] *
        digitArray[i + 12];

      if (test > answer) answer = test;
    }

    console.log("Problem 8: " + answer);
  },

  problem9: function () {
    // A Pythagorean triplet is a set of three natural numbers, a<b<c,
    // for which,a^2 + b^2 = c^2.
    //
    // For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
    //
    // There exists exactly one Pythagorean triplet for which a + b + c = 1000.
    // Find the product abc.'
    let answer = 0;
    for (let c = 1000; c >= 0; c--) {
      for (let b = c; b >= 0; b--) {
        for (let a = b; a >= 0; a--) {
          if (c > b && b > a) {
            if (c + b + a == 1000) {
              if (Math.pow(a, 2) + Math.pow(b, 2) == Math.pow(c, 2)) {
                console.log("Problem 9: c-> " + c + " b-> " + b + " a-> " + a);
                answer = a * b * c;
              }
            }
          }
        }
      }
    }

    console.log("Problem 9: " + answer);
  },

  problem10: function (n) {
    //The sum of the primes below 10 is 2+3+5+7=17.
    //
    // Find the sum of all the primes below two million.
    let answer = 0;
    // starting with an odd number
    if (n % 2 == 0) n--;
    // subtracting 1 leads to even number which we know are not prime
    // subtracting 2 leads to only odds which may be prime.
    for (let index = n; index > 1; index -= 2) {
      if (this.isPrime(index)) {
        answer += index;
      }
    }
    // the above loop will miss 2, the only even prime
    // so add it now
    answer += 2;

    console.log("Problem 10: " + answer);
  },

  problem11: function () {
    // wrong: 51,267,216
    // /In the 20×20 grid below, four numbers along a diagonal
    // line have been marked in red.
    //
    // prettier-ignore
    let arrRows = [
      [ 8, 2,22,97,38,15, 0,40, 0,75, 4, 5, 7,78,52,12,50,77,91, 8],
      [49,49,99,40,17,81,18,57,60,87,17,40,98,43,69,48, 4,56,62, 0],
      [81,49,31,73,55,79,14,29,93,71,40,67,53,88,30, 3,49,13,36,65],
      [52,70,95,23, 4,60,11,42,69,24,68,56, 1,32,56,71,37, 2,36,91],
      [22,31,16,71,51,67,63,89,41,92,36,54,22,40,40,28,66,33,13,80],
      [24,47,32,60,99, 3,45, 2,44,75,33,53,78,36,84,20,35,17,12,50],
      [32,98,81,28,64,23,67,10,26,38,40,67,59,54,70,66,18,38,64,70],
      [67,26,20,68, 2,62,12,20,95,63,94,39,63, 8,40,91,66,49,94,21],
      [24,55,58, 5,66,73,99,26,97,17,78,78,96,83,14,88,34,89,63,72],
      [21,36,23, 9,75, 0,76,44,20,45,35,14, 0,61,33,97,34,31,33,95],
      [78,17,53,28,22,75,31,67,15,94, 3,80, 4,62,16,14, 9,53,56,92],
      [16,39, 5,42,96,35,31,47,55,58,88,24, 0,17,54,24,36,29,85,57],
      [86,56, 0,48,35,71,89, 7, 5,44,44,37,44,60,21,58,51,54,17,58],
      [19,80,81,68, 5,94,47,69,28,73,92,13,86,52,17,77, 4,89,55,40],
      [ 4,52, 8,83,97,35,99,16, 7,97,57,32,16,26,26,79,33,27,98,66],
      [88,36,68,87,57,62,20,72, 3,46,33,67,46,55,12,32,63,93,53,69],
      [ 4,42,16,73,38,25,39,11,24,94,72,18, 8,46,29,32,40,62,76,36],
      [20,69,36,41,72,30,23,88,34,62,99,69,82,67,59,85,74, 4,36,16],
      [20,73,35,29,78,31,90, 1,74,31,49,71,48,86,81,16,23,57, 5,54],
      [ 1,70,54,71,83,51,54,69,16,92,33,48,61,43,52, 1,89,19,67,48],
    ]
    //
    // The product of these numbers is 26 × 63 × 78 × 14 = 1788696.
    //
    // What is the greatest product of four adjacent numbers in the same direction
    // (up, down, left, right, or diagonally) in the 20×20 grid?
    let answer = 0;
    let candidates = [];

    // table off-sets
    // [rowStart, colStart, rowEnd, colEnd]
    let modes = {
      vert: [0, 0, 3, 0],
      horz: [0, 0, 0, 3],
      diagA: [0, 0, 3, 3],
      diagB: [0, 3, 3, 0],
    };

    for (const modeName in modes) {
      const mode = modes[modeName];
      // Iterate the data rows and columns
      // Leave row to scan ahead 4 columns and/or rows
      for (let iRow = mode[0]; iRow < arrRows.length - mode[2]; iRow++) {
        let arrCols = arrRows[iRow];
        for (let iCol = mode[1]; iCol < arrCols.length - mode[3]; iCol++) {
          // Index Adders
          let ra = [0, 0, 0, 0];
          let ca = [0, 0, 0, 0];
          if (modeName == "vert") {
            ra = [0, 1, 2, 3];
          } else if (modeName == "horz") {
            ca = [0, 1, 2, 3];
          } else if (modeName == "diagA") {
            ra = [0, 1, 2, 3];
            ca = [0, 1, 2, 3];
          } else if (modeName == "diagB") {
            ra = [0, 1, 2, 3];
            ca = [0, -1, -2, -3];
          }

          let candidate = {
            mode: modeName,
            origin: iRow + ra[0] + " , " + (iCol + ca[0]),
            values:
              arrRows[iRow + ra[0]][iCol + ca[0]] +
              " , " +
              arrRows[iRow + ra[1]][iCol + ca[1]] +
              " , " +
              arrRows[iRow + ra[2]][iCol + ca[2]] +
              " , " +
              arrRows[iRow + ra[3]][iCol + ca[3]],

            result:
              arrRows[iRow + ra[0]][iCol + ca[0]] *
              arrRows[iRow + ra[1]][iCol + ca[1]] *
              arrRows[iRow + ra[2]][iCol + ca[2]] *
              arrRows[iRow + ra[3]][iCol + ca[3]],
          };
          candidates.push(candidate);
          if (answer < candidate.result) {
            answer = candidate.result;
          }
        }
      }
    }

    console.log("Problem 11: " + answer);
  },

  problem12: function () {
    // The sequence of triangle numbers is generated by adding the natural numbers.
    // So the 7th triangle number would be 1+2+3+4+5+6+7=28.
    // The first ten terms would be:
    // 1,3,6,10,15,21,28,36,45,55,…
    // Let us list the factors of the first seven triangle numbers:
    //       1: 1
    //       3: 1,3
    //       6: 1,2,3,6
    //      10: 1,2,5,10
    //      15: 1,3,5,15
    //      21: 1,3,7,21
    //      28: 1,2,4,7,14,28
    // We can see that 28 is the first triangle number to have over five divisors.
    // What is the value of the first triangle number to have over five hundred divisors?

    let answer = 0;
    let nn = 1;
    let factorLength = 0;
    do {
      answer += nn;
      factors = this.factors(answer).factors;
      nn++;
    } while (factors.length <= 500);

    console.log("Problem: 12: " + answer);
  },

  problem13: function () {
    //Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.
    let arrNumbers = [
      37107287533902102798797998220837590246510135740250,
      46376937677490009712648124896970078050417018260538,
      74324986199524741059474233309513058123726617309629,
      91942213363574161572522430563301811072406154908250,
      23067588207539346171171980310421047513778063246676,
      89261670696623633820136378418383684178734361726757,
      28112879812849979408065481931592621691275889832738,
      44274228917432520321923589422876796487670272189318,
      47451445736001306439091167216856844588711603153276,
      70386486105843025439939619828917593665686757934951,
      62176457141856560629502157223196586755079324193331,
      64906352462741904929101432445813822663347944758178,
      92575867718337217661963751590579239728245598838407,
      58203565325359399008402633568948830189458628227828,
      80181199384826282014278194139940567587151170094390,
      35398664372827112653829987240784473053190104293586,
      86515506006295864861532075273371959191420517255829,
      71693888707715466499115593487603532921714970056938,
      54370070576826684624621495650076471787294438377604,
      53282654108756828443191190634694037855217779295145,
      36123272525000296071075082563815656710885258350721,
      45876576172410976447339110607218265236877223636045,
      17423706905851860660448207621209813287860733969412,
      81142660418086830619328460811191061556940512689692,
      51934325451728388641918047049293215058642563049483,
      62467221648435076201727918039944693004732956340691,
      15732444386908125794514089057706229429197107928209,
      55037687525678773091862540744969844508330393682126,
      18336384825330154686196124348767681297534375946515,
      80386287592878490201521685554828717201219257766954,
      78182833757993103614740356856449095527097864797581,
      16726320100436897842553539920931837441497806860984,
      48403098129077791799088218795327364475675590848030,
      87086987551392711854517078544161852424320693150332,
      59959406895756536782107074926966537676326235447210,
      69793950679652694742597709739166693763042633987085,
      41052684708299085211399427365734116182760315001271,
      65378607361501080857009149939512557028198746004375,
      35829035317434717326932123578154982629742552737307,
      94953759765105305946966067683156574377167401875275,
      88902802571733229619176668713819931811048770190271,
      25267680276078003013678680992525463401061632866526,
      36270218540497705585629946580636237993140746255962,
      24074486908231174977792365466257246923322810917141,
      91430288197103288597806669760892938638285025333403,
      34413065578016127815921815005561868836468420090470,
      23053081172816430487623791969842487255036638784583,
      11487696932154902810424020138335124462181441773470,
      63783299490636259666498587618221225225512486764533,
      67720186971698544312419572409913959008952310058822,
      95548255300263520781532296796249481641953868218774,
      76085327132285723110424803456124867697064507995236,
      37774242535411291684276865538926205024910326572967,
      23701913275725675285653248258265463092207058596522,
      29798860272258331913126375147341994889534765745501,
      18495701454879288984856827726077713721403798879715,
      38298203783031473527721580348144513491373226651381,
      34829543829199918180278916522431027392251122869539,
      40957953066405232632538044100059654939159879593635,
      29746152185502371307642255121183693803580388584903,
      41698116222072977186158236678424689157993532961922,
      62467957194401269043877107275048102390895523597457,
      23189706772547915061505504953922979530901129967519,
      86188088225875314529584099251203829009407770775672,
      11306739708304724483816533873502340845647058077308,
      82959174767140363198008187129011875491310547126581,
      97623331044818386269515456334926366572897563400500,
      42846280183517070527831839425882145521227251250327,
      55121603546981200581762165212827652751691296897789,
      32238195734329339946437501907836945765883352399886,
      75506164965184775180738168837861091527357929701337,
      62177842752192623401942399639168044983993173312731,
      32924185707147349566916674687634660915035914677504,
      99518671430235219628894890102423325116913619626622,
      73267460800591547471830798392868535206946944540724,
      76841822524674417161514036427982273348055556214818,
      97142617910342598647204516893989422179826088076852,
      87783646182799346313767754307809363333018982642090,
      10848802521674670883215120185883543223812876952786,
      71329612474782464538636993009049310363619763878039,
      62184073572399794223406235393808339651327408011116,
      66627891981488087797941876876144230030984490851411,
      60661826293682836764744779239180335110989069790714,
      85786944089552990653640447425576083659976645795096,
      66024396409905389607120198219976047599490197230297,
      64913982680032973156037120041377903785566085089252,
      16730939319872750275468906903707539413042652315011,
      94809377245048795150954100921645863754710598436791,
      78639167021187492431995700641917969777599028300699,
      15368713711936614952811305876380278410754449733078,
      40789923115535562561142322423255033685442488917353,
      44889911501440648020369068063960672322193204149535,
      41503128880339536053299340368006977710650566631954,
      81234880673210146739058568557934581403627822703280,
      82616570773948327592232845941706525094512325230608,
      22918802058777319719839450180888072429661980811197,
      77158542502016545090413245809786882778948721859617,
      72107838435069186155435662884062257473692284509516,
      20849603980134001723930671666823555245252804609722,
      53503534226472524250874054075591789781264330331690,
    ];
    let answer = 0;

    arrNumbers.forEach((n) => {
      answer += n;
    });

    answer = answer.toString();
    if (answer.includes("e+")) {
      answer = answer.split("e+")[0].replace(".", "");
    }
    answer = answer.substring(0, 10);

    console.log("Problem 13: " + answer);
  },
  problem14: function () {
    // The following iterative sequence is defined for the set of positive integers:

    // n→n/2 (n is even)
    // n→3n+1 (n is odd)
    // Using the rule above and starting with 13, we generate the following sequence:
    // 13→40→20→10→5→16→8→4→2→1.
    // It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.
    // Which starting number, under one million, produces the longest chain?
    // NOTE: Once the chain starts the terms are allowed to go above one million.

    let answer = 0;
    let longest = 0;
    let trackResults = {};
    //Investigate Starting Numbers
    for (let sn = 999999; sn > 0; sn--) {
      let sequenceNumber = sn;
      let sequence = [sequenceNumber];
      while (sequenceNumber > 1) {
        if (sequenceNumber % 2 == 0) {
          sequenceNumber = sequenceNumber / 2;
        } else {
          sequenceNumber = 3 * sequenceNumber + 1;
        }
        sequence.push(sequenceNumber);
      }
      // Record the sequence for this starting number
      trackResults[sn] = sequence;
      if (longest < sequence.length) {
        longest = sequence.length;
        answer = sn;
      }
    }

    console.log("Problem 14: " + answer + " -> sequence length: " + longest);
  },

  problem15: function (gridSize) {
    // Starting in the top left corner of a 2×2 grid, and only being able to move to the right and down,
    // there are exactly 6 routes to the bottom right corner.
    //
    // How many such routes are there through a 20×20 grid?

    // Sides of the boxes define the row and column count since the sides
    // of the boxes define the path of travel.
    // Example: a 2 box x 2 box grid has 3 rows and 3 columns
    // 1 x 1 -> 2 unique vert. sides 2 paths
    // 2 x 2 -> 6 unique vert. sides 6 paths
    // 3 x 3 -> 9 unique vert. sides 20 paths
    let columnSize = gridSize + 1;
    let rowSize = gridSize + 1;

    let answer = 0;
    // Find all possible route through an iterative stepping algorythm
    answer = this.nextRouteStep(1, 1, columnSize, rowSize);
    // Count up the route that made it to the end.

    console.log("Problem 15: " + answer);
  },

  // Step through all the diffent moves on a route until
  // max x and Y is hit.
  paths: {},
  nextRouteStep: function (x, y, maxX, maxY) {
    //if (x == maxX && y == maxY) debugger;
    let pathCount = 0;
    // No need to trace from known nodes more than once.
    // pull paths from known nodes from cache
    if (this.paths[x + "_" + y]) {
      // The paths from this node forward have already been traced
      // Only need to return the path count for this node
      // instead of interating over the child nodes again
      pathCount = this.paths[x + "_" + y];
    } else {
      // The paths from this node have NOT been traced.
      // Process the unknown node
      // Path to End in X direction (Horizontal)
      newPathCount = 0;
      if (x < maxX) {
        newPathCount += this.nextRouteStep(x + 1, y, maxX, maxY);
      }
      // Path to End in Y direction (Vertical)
      if (y < maxY) {
        newPathCount += this.nextRouteStep(x, y + 1, maxX, maxY);
      }

      // If the current node is the last node (far lower right)
      // then set the path count to one because adjacent nodes
      // will have only one path to get here.
      if (x == maxX && y == maxY) newPathCount = 1;

      // Create the new node
      this.paths[x + "_" + y] = newPathCount;
      pathCount = newPathCount;
    }

    return pathCount;
  },

  problem16: function (a, b) {
    // 2^15 = 32768 and the sum of its digits is 3+2+7+6+8 = 26.
    //
    // What is the sum of the digits of the number 2^1000?
    let answer = 0;

    //let arrValues = Math.pow(a, b).toString().split("");
    // the above line only works in Javascript upto the MAX SAFE INTEGER of
    // 9,007,199,254,740,991 or nine quadrillion. Larger results will trigger
    //the Math.pow function to return scientific notation, 1.234567e+200
    //let arrValues = (a ** b).toString().split("");
    // the above line using ** as the same problem.
    // The following line is developed for NodeJS on Mac.

    let arrValues = cp
      .execSync("bc --expression=" + a + "^" + b)
      .toString()
      .split("");
    arrValues.forEach((x) => {
      if (Number.isInteger(parseInt(x))) answer += parseInt(x);
    });

    console.log("Problem 16: " + answer);
  },
  problem17: function (n) {
    // If the numbers 1 to 5 are written out in words: one, two, three, four, five,
    // then there are 3+3+5+4+4=19 letters used in total.
    //
    // If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words,
    // how many letters would be used? \nNOTE: Do not count spaces or hyphens. For example,
    // 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen)
    // contains 20 letters. The use of "and" when writing out numbers is in compliance with British usage.

    let answer = 0;
    let map = {
      1: "one",
      2: "two",
      3: "there",
      4: "four",
      5: "five",
      6: "six",
      7: "seven",
      8: "eight",
      9: "nine",
      10: "ten",
      11: "eleven",
      12: "twelve",
      13: "thirteen",
      14: "fourteen",
      15: "fifteen",
      16: "sixteen",
      17: "seventeen",
      18: "eighteen",
      19: "nineteen",
      20: "twenty",
      30: "thirty",
      40: "forty",
      50: "fifty",
      60: "sixty",
      70: "seventy",
      80: "eigthy",
      90: "ninety",
    };

    let allNumbersString = "";

    // Iterate 1 to n (upto 9999)
    for (let index = 1; index <= n; index++) {
      let numString = index.toString();

      // map
      // Check for direct mapping
      if (map[numString]) {
        allNumbersString += " " + map[numString];
        console.log(map[numString]);
      } else {
        // parsing is required
        let parsedString = "";
        // Thousands upto 9999
        // Example: 100 tho = undefined; hun = "one"; ten = undefined; one = undefined
        // Example: 999 tho = undefined; hun = "nine"; ten = ninety; one = nine
        let tho = map[numString.split("").reverse()[3]];
        let hun = map[numString.split("").reverse()[2]];
        // ten slot has special cases 10-20, 30, 40 ...
        let tenRaw = numString.split("").reverse()[1];
        let oneRaw = numString.split("").reverse()[0];
        let ten = undefined;
        let one = undefined;
        if (map[tenRaw + oneRaw]) {
          ten = map[tenRaw + oneRaw];
        } else {
          ten = map[tenRaw + "0"];
          one = map[oneRaw];
        }

        if (tho) parsedString += tho + " thousand ";
        if (hun) parsedString += hun + " hundred ";
        if (hun && (ten || one)) parsedString += "and ";
        if (ten) parsedString += ten + " ";
        if (one) parsedString += one;
        allNumbersString += " " + parsedString;
        console.log(parsedString);
      }
    }

    console.log("Problem 17: " + allNumbersString.replace(/\s/g, "").length);
  },
};

module.exports = problems;
//console.log(JSON.stringify(problems.problem16(2, 1000)));
problems.problem17(1000);
debugger;
